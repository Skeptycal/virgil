// Copyright 2017 Google Inc. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

class SyntaxMigrater(file: ParsedFile) extends VstVisitor<void, void> {
	var patched = false;
	var delta = 0;
	def replaces = Vector<(int, string, string)>.new();

	def reset() {
		delta = 0;
		replaces.length = 0;
		patched = false;
	}
        def visitD(decl: Decl) {
		if (VstCompound.?(decl)) {
			var c = VstCompound.!(decl);
			def f: VstMember -> void = visitD;
			Lists.apply(c.members, f);
		} else if (VstMethod.?(decl)) {
			visitS(VstMethod.!(decl).body);
		} else if (VstField.?(decl)) {
			visitE(VstField.!(decl).init);
		} else if (VarDecl.?(decl)) {
                	visitE(VarDecl.!(decl).init);
                }
       	}
	def visitS(s: Stmt) {
		if (s != null) s.accept<void, void>(this, ());
	}
	def visitE(e: Expr) {
		if (e != null) e.accept<void, void>(this, ());
	}
	def visitIf(stmt: IfStmt, env: void) {
		visitE(stmt.cond);
		visitS(stmt.tbranch);
		visitS(stmt.fbranch);
	}
	def visitBlock(stmt: BlockStmt, env: void) {
		for (s in stmt.stmts.asArray()) visitS(s);
	}
	def visitWhile(stmt: WhileStmt, env: void) {
		visitE(stmt.cond);
		visitS(stmt.body);
	}
	def visitFor(stmt: ForStmt, env: void) {
		visitE(stmt.varDecl.init);
		visitE(stmt.cond);
		visitE(stmt.update);
		visitS(stmt.body);
	}
	def visitForeach(stmt: ForeachStmt, env: void) {
		visitE(stmt.varDecl.init);
		visitE(stmt.expr);
		visitS(stmt.body);
	}
	def visitForLess(stmt: ForLessStmt, env: void) {
		visitE(stmt.varDecl.init);
		visitE(stmt.expr);
		visitS(stmt.body);
	}
	def visitLocal(stmt: LocalStmt, env: void) {
		for (p = stmt.vars; p != null; p = p.tail) visitE(p.head.init);
	}
	def visitBreak(stmt: BreakStmt, env: void) {
		// do nothing
	}
	def visitContinue(stmt: ContinueStmt, env: void) {
		// do nothing
	}
	def visitExpr(stmt: ExprStmt, env: void) {
		visitE(stmt.expr);
	}
	def visitMatch(stmt: MatchStmt, env: void) {
		visitE(stmt.expr);
		for (c in stmt.cases.asArray()) {
			visitS(c.stmt);
			patchCase(c);
		}
		if (stmt.defcase != null) visitS(stmt.defcase.stmt);
	}
	def patchCase(c: MatchCase) {
		// migrate 0: foo()  to 0 => foo()
		var start: FilePoint;
		if (c.default != null) {
			start = c.default;
		} else {
			var ps = c.patterns.asArray(), p = ps[ps.length - 1];
			if (p.params != null) start = p.params.range().end();
			else start = p.expr.range().end();
		}
		// Find the colon separating the pattern from the statement.
		var r = c.stmt.range(), end = charOffset(r.beginLine, r.beginColumn);
		for (pos = charOffset(start.beginLine, start.beginColumn); pos < end; pos++) {
			if (file.input[pos] == ':') {
				if (file.input[pos-1] == ' ') replace(pos, ":", "=>");
				else replace(pos, ":", " =>");
				break;
			}
		}
	}
	def visitEmpty(stmt: EmptyStmt, env: void) {
		// do nothing
	}
	def visitReturn(stmt: ReturnStmt, env: void) {
		visitE(stmt.expr);
	}

	def visitTuple(expr: TupleExpr, env: void) {
		for (e in expr.exprs.asArray()) visitE(e);
	}
	def visitParamExpr(expr: ParamExpr, env: void) {
		// do nothing
	}
	def visitAutoExpr(expr: AutoExpr, env: void) {
		if (AppExpr.?(expr.expr)) record(AppExpr.!(expr.expr));
	}
	def visitArray(expr: ArrayExpr, env: void) {
		for (e in expr.exprs.asArray()) visitE(e);
	}
	def visitVar(expr: VarExpr, env: void) {
		visitE(expr.expr);
	}
	def visitLiteral(expr: Literal, env: void) {
		// do nothing
	}
	def visitString(expr: StringExpr, env: void) {
		// do nothing
	}
	def visitApp(expr: AppExpr, env: void) {
		if (V3.isArray(expr.func.exactType)) record(expr);
		visitE(expr.func);
		for (e in expr.args.exprs.asArray()) visitE(e);
	}
	def visitIndex(expr: IndexExpr, env: void) {
		visitE(expr.expr);
		for (e in expr.exprs.asArray()) visitE(e);
	}
	def visitNot(expr: NotExpr, env: void) {
		visitE(expr.expr);
	}
	def visitBitwiseNeg(expr: BitwiseNegExpr, env: void) {
		visitE(expr.expr);
	}
	def visitAssign(expr: AssignExpr, env: void) {
		if (AppExpr.?(expr.target)) record(AppExpr.!(expr.target));
		visitE(expr.target);
		visitE(expr.expr);
	}
	def visitBinOp(expr: BinOpExpr, env: void) {
		visitE(expr.left);
		visitE(expr.right);
	}
	def visitIfExpr(expr: IfExpr, env: void) {
		for (e in expr.exprs.asArray()) visitE(e);
	}
	def record(app: AppExpr) {
		var range = app.args.range();
		patch(range.beginLine, range.beginColumn, '(', '[');
		patch(range.endLine, range.endColumn - 1, ')', ']');
	}
	def patch(line: int, col: int, a: byte, b: byte) {
		var pos = charOffset(line, col);
		if (file.input[pos] != a && file.input[pos] != b) {
			var buf = StringBuffer.new().puts("Could not patch \'").putc(a).puts("\' to \'").putc(b).puts(" at ").puts(file.fileName).puts(":").puti(line).puts(":").puti(col);
			return V3.fail(buf.toString());
		}
		file.input[pos] = b;
		patched = true;
	}
	def charOffset(line: int, col: int) -> int {
		var pos = file.lineStartOffset(line);
		var end = file.lineEndOffset(line);
		var c = 1;
		while (pos < end) {
			var ch = file.input[pos];
			if (c == col) break;
			if (ch == '\t') c = 1 + (((c + 8) >>> 3) << 3); // tab character
			else c++;
			pos++;
		}
		return pos;
	}
	def replace(pos: int, input: string, output: string) {
		patched = true;
		if (input.length == output.length) {
			// replacement fits exactly.
			for (i < output.length) file.input[pos + i] = output[i];
		} else {
			// replacement requires copying the file over.
			replaces.add(pos, input, output);
			delta += output.length - input.length;
		}
	}
	def cmpPatch(a: (int, string, string), b: (int, string, string)) -> bool {
		return a.0 < b.0;
	}
        def rewrite() {
        	if (!patched) return;
		Terminal.put1("Writing %1\n", file.fileName);
		var fd = System.fileOpen(file.fileName, false);
		var data = file.input;
		var num_replaces = replaces.length;
		if (num_replaces > 0) {
			var ndata = Array<byte>.new(data.length + delta);
			var oldpos = 0, newpos = 0;
			for (p in Arrays.sort(replaces.extract(), 0, num_replaces, cmpPatch)) {
				var len = p.0 - oldpos;
				for (i < len) ndata[newpos++] = data[oldpos++];
				for (i < p.2.length) ndata[newpos++] = p.2[i];
				oldpos += p.1.length;
			}
			while (oldpos < file.input.length) ndata[newpos++] = data[oldpos++];
			data = ndata;
		}
		System.fileWriteK(fd, data, 0, data.length);
		System.fileClose(fd);
                patched = false;
       	}
}
